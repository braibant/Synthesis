\documentclass[a4]{article}
\usepackage{fullpage}
\usepackage{macros}
\usepackage{lstcoq}
\usepackage{mathpartir}

\usepackage{amsfonts}

\usepackage[maxnames=6,style=numeric-comp,hyperref=true,bibencoding=inputenc]{biblatex}
\bibliography{synthesis}

\title{Formal verification of hardware synthesis}
\author{
  Thomas Braibant\\
  University of Grenoble,
  currently visiting MIT
  \and
  Adam Chlipala\\
  MIT
}
\date{Coq Workshop 2012}
\newcommand\project{BabyHardCert}

\begin{document}

\maketitle

Verification of hardware designs has been thoroughly investigated, and
yet, obtaining provably correct hardware of significant complexity is
usually considered challenging and time-consuming. 
%
On the one hand, a common practice in hardware verification is to  take a given design
written in an hardware description language like Verilog or VHDL,
and argue about this design in a formal way using a model checker or
an SMT solver. 
%
On the second hand, a completely different approach is to design hardware via a
shallow-embedding of circuits in a theorem
prover~\cite{hanna-veritas,UCAM-CL-TR-77,hunt89,vamp,certifying-circuits-in-type-theory}. 
%
Yet, both kind of approach suffer from the fact that most hardware
designs are expressed in low-level RTL languages like Verilog or
VHDL, and that the level of abstraction they provide may be too low to
do short and meaningful proof of high-level properties. 

\medskip

To raise this level of abstraction, industry moved to \emph{hardware
  synthesis} using higher-level languages, e.g., System-C,
Esterel~\cite{DBLP:conf/birthday/Berry00} or
Bluespec~\cite{bluespec}, in which a high-level source program is
compiled to an RTL description. 
%
High-level synthesis has two benefits. 
%
First, it reduces the effort necessary to produce an hardware design.
%
Second, writing or reasoning about a high-level program is simpler
than reasoning about the (much more complicated) RTL description
generated by a compiler.
%
However, the downside of high-level synthesis is that there is no
formal guarantee that the generated circuit description behaves
exactly as prescribed by the semantics of the source
program, making verification on the high-level program useless in the
presence of compiler-introduced bugs.
%

\medskip

We are currently working on a project that address this issue.  That
is, we investigate the formal verification of a (toy) compiler from a
Bluespec-inspired language called \project{} to RTL, quite
literally applying the ideas behind the CompCert
project~\cite{Leroy-Compcert-CACM} to hardware synthesis. 

\medskip

\project{} can be seen as a stripped-down and simplified version
of Bluespec: in both languages, hardware designs are described in
terms of \emph{guarded atomic actions} on storage elements. 
%
In our development, we define a (dependently-typed) deep-embedding of
the \project{} programming language in Coq using \emph{parametric
  higher-order abstract syntax (PHOAS)}~\cite{phoas-chlipala}, and
give it a semantics using an interpreter: the semantics of a program
is a Coq function that takes as inputs the current state of the
storage elements and a list of updates to be commited to this storage
elements, and produces another list of updates to be commited.
%
The one odditiy here is that this language and its semantics have a
flavour of \emph{transactional memory}, where updates to state
elements are not visible before the end of the transaction (a
time-step).
%
Our target language can be sensibly interpreted as \emph{clocked
  sequential machines}: we generate an RTL description syntactically
described as combinational definitions and next-state
assignements. (Note that we do not investigate yet the correctness of an
\emph{actual} implementation of this RTL description using the
synthesisable subsets of Verilog or VHDL.)

\medskip

In this talk, we shall present the current state of our development,
and highlight some of its features. For instance, we look forward to
discuss the oddities of the semantics of our hardware description
languages, as well as the payoffs of our various  implementation choices,
including the use of PHOAS. 

\newpage

\printbibliography

\end{document}
