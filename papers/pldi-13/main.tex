\documentclass[preprint]{sigplanconf}

\usepackage{macros}
\usepackage{lstcoq}
\usepackage{mathpartir}
\usepackage{amsfonts}
\usepackage{amsmath}

\authorinfo{Thomas Braibant}
           {UdG/MIT}
           {thomas.braibant@inria.fr}
\authorinfo{Adam Chlipala}
           {MIT}
           {adamc@csail.mit.edu}
\title{Formal verification of hardware synthesis}
\newcommand{\project}{Fe-Si}
\begin{document}
\maketitle

\begin{abstract}
  We report on the implementation of a certified compiler for an
  high-level hardware description language (HDL) called \emph{Fe-Si}
  (Featherweight Synthesis).

  Fe-Si is a simplified version of Bluespec, an HDL based on a notion
  of \emph{guarded atomic actions}. Fe-Si is defined as a
  dependently-typed deep-embedding in Coq. The target language of the
  compiler corresponds to a synthesisable subset of Verilog or VHDL.
  
  One key of our approach is that input programs to the compiler can
  be defined and proved correct inside Coq. Then, we use extraction
  and a Verilog back-end (written in OCaml) to get a certified version
  of some hardware-designs.
\end{abstract}

\section*{Introduction}
Verification of hardware designs has been thoroughly investigated, and
yet, obtaining provably correct hardware of significant complexity is
usually considered challenging and time-consuming. 
%
On the one hand, a common practice in hardware verification is to  take a given design
written in an hardware description language like Verilog or VHDL,
and argue about this design in a formal way using a model checker or
an SMT solver. 
%
On the second hand, a completely different approach is to design hardware via a
shallow-embedding of circuits in a theorem
prover~\cite{hanna-veritas,UCAM-CL-TR-77,hunt89,vamp,certifying-circuits-in-type-theory}. 
%
Yet, both kind of approach suffer from the fact that most hardware
designs are expressed in low-level RTL languages like Verilog or 
VHDL, and that the level of abstraction they provide may be too low to
do short and meaningful proof of high-level properties. 

\medskip

To raise this level of abstraction, industry moved to \emph{hardware
  synthesis} using higher-level languages, e.g., System-C,
Esterel~\cite{DBLP:conf/birthday/Berry00} or
Bluespec~\cite{bluespec}, in which a high-level source program is
compiled to an RTL description. 
%
High-level synthesis has two benefits. 
%
First, it reduces the effort necessary to produce an hardware design.
%
Second, writing or reasoning about a high-level program is simpler
than reasoning about the (much more complicated) RTL description
generated by a compiler.
%
However, the downside of high-level synthesis is that there is no
formal guarantee that the generated circuit description behaves
exactly as prescribed by the semantics of the source
program, making verification on the high-level program useless in the
presence of compiler-introduced bugs.
%

\medskip In this paper, we investigate the formal verification of a
lightly optimizing compiler from a Bluespec-inspired language called
\project{} to RTL, quite literally applying the ideas behind the
CompCert project~\cite{Leroy-Compcert-CACM} to hardware synthesis.

\medskip

\project{} can be seen as a stripped-down and simplified version
of Bluespec: in both languages, hardware designs are described in
terms of \emph{guarded atomic actions} on storage elements. 
%
In our development, we define a (dependently-typed) deep-embedding of
the \project{} programming language in Coq using \emph{parametric
  higher-order abstract syntax (PHOAS)}~\cite{phoas-chlipala}, and
give it a semantics using an interpreter: the semantics of a program
is a Coq function that takes as inputs the current state of the
storage elements and a list of updates to be commited to this storage
elements, and produces another list of updates to be commited.
%
The one odditiy here is that this language and its semantics have a
flavour of \emph{transactional memory}, where updates to state
elements are not visible before the end of the transaction (a
time-step).
%
Our target language can be sensibly interpreted as \emph{clocked
  sequential machines}: we generate an RTL description syntactically
described as combinational definitions and next-state
assignements. (Note that we do not investigate yet the correctness of an
\emph{actual} implementation of this RTL description using the
synthesisable subsets of Verilog or VHDL.)


\section{Testing designs}
In order to gain confidenced in the fact that there is no lapse in
either the semantics of the source language, nor the semantics of the
target language, we test the simulated execution of compiled designs
against our semantics. 

Indeed, our use of program extraction is more delicate than what is
done in, e.g., CompCert, because our program transformations use
dependent type intensively. Either Coq extraction mechanism or
our Verilog back-end could introduce bugs in the generated code.

Moreover, since the long-term idea is to generate high-confidence
hardware, one should not blindly trust formally certified code that
has not been tested. 

% \category{CR-number}{subcategory}{third-level}

% \terms
% term1, term2

% \keywords
% keyword1, keyword2


\acks Acknowledgement

\bibliographystyle{abbrvnat}
\bibliography{synthesis}

\end{document}
